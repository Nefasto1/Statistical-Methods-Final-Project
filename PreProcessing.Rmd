---
title: "Final_Project"
author: "Nicola Cortinovis, Roberta Lamberti, Marta Lucas, Stefano Tumino"
date: "`r Sys.Date()`"
output: html_document
---
# Initial setup
```{r}
#install.packages("mgcv")
#install.packages("dplyr")
#install.packages("rpart")
#install.packages("rpart.plot")
#install.packages("ipred")
#install.packages("caret")
#install.packages("stringr")
#install.packages("ggcorrplot")
```

## Import libraries
```{r}
library(stringr)
library(mgcv)        # GAMs
library(rsample)     # data splitting
library(dplyr)       # data wrangling
library(rpart)       # performing regression trees
library(rpart.plot)  # plotting regression trees
library(ipred)       # bagging
library(caret)
library(ggcorrplot)
```

## Import dataset
```{r}
df <- read.csv("phones_data.csv", header=T)

summary(df)
```
## Dataset 

| Variables      |       Description                            |    Type     |
| -------------  | -------------------------------------------  |-------------|
| brand_name     | Name of the phone brand                      |     chr     |
| model_name     | Name of the phone model                      |     chr     |
|    os          |    Operating system                          |     chr     |
| Popularity     | The popularity of the phone in range 1-1224  |     int     |
| Best Price     | Best price of the price-range in (UAH)       |     num     |
| Lowest Price   | Highest price of the price-range in (UAH)    |     num     |
| highest_price  | Lowest price of the price-range in (UAH)     |     num     |
| Sellers amount |   The amount sellers sold the phone          |     num     |
| Screen size    |  The size of phone's screen (inches).        |     num     |
| Memory size    |  The size of the phone's memory (GB)         |     num     |
| Battery size   |  The size of the phone's battery (mAh)       |     num     |
| Release date   |  The launch date of the product on the market|     chr     |

## Variable cleaning

### Remove useless variables
TODO: elenco variabili categoriali e spiegazioni sul dataset
```{r}
# rimozione colonna degli indici
df$X <- NULL
```

### Factorize the categorical variables
```{r}
df$brand_name <- factor(df$brand_name)
df$os <- factor(df$os)
```

### Convert the prices to euros
```{r}

df$best_price <- df$best_price*0.024
df$lowest_price <- df$lowest_price*0.024
df$highest_price <- df$highest_price*0.024
```

### Remove me
```{r}
table(df$os)

# plot(df[df$os == ""], df$memory_size[df$os == ""])

#hist(df$memory_size[df$os != c("Android","iOS")])
hist(df$memory_size[df$os == "EMUI"], xlim = c(0,1000), col = "red", ylim = c(0,100))
hist(df$memory_size[df$os == "KAIOS"], xlim = c(0,1000), add = TRUE, col = "blue")
hist(df$memory_size[df$os == "OxygenOS"], xlim = c(0,1000), add = TRUE, col = "green")
hist(df$memory_size[df$os == "WindowsPhone"], xlim = c(0,1000), add = TRUE, col = "purple")
hist(df$memory_size[df$os == ""], xlim = c(0,1000), add = TRUE, col = "yellow")
```

### Make the os variable more readable

```{r}
levels(df$os) <- c("other", "Android", "Android", "iOS", "other", "Android", "Android")
```

### Gestione Meizu outlier
```{r}
df[df$os == "other", ][which.max(df$memory_size[df$os == "other"]),] # soft check
df[df$os == "other", ][which.max(df$memory_size[df$os == "other"]),]$os = "Android"

```

### Split the timestamps
```{r}
df$month <- as.numeric(sapply(df$release_date, FUN = function(x) {strsplit(x, split = '[-]')[[1]][1]}))
df$year <- as.numeric(sapply(df$release_date, FUN = function(x) {strsplit(x, split = '[-]')[[1]][2]}))-2000
```

# Dataset cleaning 
- sistema operativo mancante modelli molto vecchi di telefoni, non sono smartphone 
- memory size mancante per gli stessi 

## Remove duplicated rows
```{r}

idxs <- which(duplicated(df[,c(-2, -4)]))

succ <- idxs[-length(idxs)] - idxs[-1] == -1
succ <- c(succ, FALSE)

i = 1
while (i <= length(idxs)){
  start = idxs[i]-1
  sum <- c(df$popularity[idxs[i]])
  while (succ[i] == TRUE){
    i = i + 1
    sum <- c(sum, df$popularity[idxs[i]])
  }
  df$popularity[start] <- mean(c(sum, df$popularity[start]))
  i = i + 1
}

df <- df[-idxs, ]

```

 
Let's divide the popularity into levels,assigning three levels associated with a numeric score. (Da mettere dopo, forse considerare split 25/50/25 (low/med/high) con i quartili)
- From 0 to 25% -> low
- From 25% to 50% -> medium-low
- From 50% to 75% -> medium-high
- From 75% to 100% -> high

```{r}
df$popularity <- as.numeric(df$popularity)

# tag <- c(0, quantile(df$popularity, 0.25), quantile(df$popularity, 0.5),quantile(df$popularity, 0.75), Inf)

tag <- quantile(df$popularity)

df$popularity_levels <- cut(df$popularity, breaks = tag,
labels=c("low", "medium-low", "medium-high", "high"), include.lowest=TRUE)

```

## Manage missing values
Since there are only 10 missing values for battery size and 2 NAs for screen size, we can drop those observations.

We notice that most of the missing values for memory size are relative to phones that are not smart-phones, for this reason we decided to substitute them with the median of the values for memory size of non-smartphones.TODO: sistemare
For the highest/lowest price we'll just substitute the mean of those columns.

### Drop Battery and Screen size missing values rows
```{r}
df <- df[- which(is.na(df$battery_size)),]
df <- df[- which(is.na(df$screen_size)),]
```

### Impute memory size missing values

We notice that most of the missing values are not smartphones... (os) TODO: spiegare quello che abbiamo fatto per la media
```{r}
tmp <- df[which(df$os == "other"),]$memory_size
df$memory_size[which(is.na(df$memory_size))] <- median(tmp[-which(is.na(tmp))])
```


### substitute the highest/lowest price NA with the median of the column
```{r}
tmp <- which(is.na(df$lowest_price))
df$lowest_price[tmp] <- median(df$lowest_price[-tmp])
```

```{r}
tmp <- which(is.na(df$highest_price))
df$highest_price[tmp] <- median(df$highest_price[-tmp])

```

### Remove useless variables
(le possiamo tenere per mantenere le info delle righe, ma non usiamo nei modelli)
```{r}
# remove useless variables
#df$model_name <- NULL
#df$release_date <- NULL
#df$popularity <- NULL
```

# Data Analysis
## Correlation matrix
```{r}
corr <- cor(df[, c(-1,-2, -3, -12, -13, -14, -15)], use="complete.obs" )

ggcorrplot(corr, hc.order = TRUE, lab = TRUE, colors=c("yellow", "white", "purple"))
```
TODO: explain what columns need to be removed (highest/lowest price)
## Single plots and Outlier analysis
### Numerical
TODO: -boxplots/other ideas
```{r}
cols <- c(5, 8:11)

for (i in cols) {
  layout(mat=matrix(c(1,2),2,1,byrow = TRUE), height = c(1,8) )
  par(mar=c(0,3.1,1.1,2.1))
  boxplot(df[, i], horizontal = TRUE,  xaxt = "n", col= "yellow", frame= F, main=colnames(df)[i]) # xaxt
  par(mar=c(4,3.1,1.1,2.1))
  hist(df[, i],border = F, main = "", col="purple")
}
```
### Categorical
Capire come gestire i brand names nei plot delle categoriali. Ricordarsi dell'interpretazione del best price al variare dei mesi (09/10 release Iphone , 02 release molti Samsung)
```{r}
for (i in c(1, 3, 13, 14, 15)) {
  barplot(sort(table(df[, i])), main=colnames(df)[i], col="purple")
}

for (i in c(1, 3, 13, 14, 15)) {
  boxplot(df$best_price ~ df[, i], col= "yellow", frame= F, main=colnames(df)[i])
}
```

### Pairs plot
```{r fig.height=7.5, fig.width=7.5}
pairs(df[cols], pch=19, lower.panel=panel.smooth)
```

# Preprocessing

## Transformations

### Log transformation
```{r}
for (i in c(5:8, 11)){
  df[, i] <- log(df[, i])
}
```

### Log2 transformation
```{r}
df$memory_size <- floor(log2(df$memory_size*1e4))
```

### Add categorical variable

The variables memory size and screen size are bimodal, we can add a categorical variable which differentiate smartphones from phones.
We can do this setting to 1 (smartphone) if the memory size is greater than 14 and the screen size is greater than 3.5, 0 (phones) otherwise.


```{r}
df$phone_type <- factor((df$memory_size < 14), labels = c("smartphone", "phone"))
```

### Check me

```{r}
cols <- c(5, 8:11)

for (i in cols) {
  layout(mat=matrix(c(1,2),2,1,byrow = TRUE), height = c(1,8) )
  par(mar=c(0,3.1,1.1,2.1))
  boxplot(df[, i], horizontal = TRUE,  xaxt = "n", col= "yellow", frame= F, main=colnames(df)[i]) # xaxt
  par(mar=c(4,3.1,1.1,2.1))
  hist(df[, i],border = F, main = "", col="purple")
}
```

Da vedere se ha senso separare (solo durante la data analysis) le due "famiglie"
Da fare un ciclo per vedere tutte le var al cambiare di phone type.
```{r}
colnames(df)
cols <- c(5, 8:11, 13, 14)
for (i in cols){
  layout(mat=matrix(c(1,2),2,1,byrow = TRUE), height = c(1,8) )
  par(mar=c(0,3.1,1.1,2.1))
  boxplot(df[,i] ~ df$phone_type, horizontal = TRUE,  xaxt = "n", col= "yellow", frame= F, main=colnames(df)[i], ylim=c(min(df[,i])-1, max(df[,i])+1))
  par(mar=c(4,3.1,1.1,2.1))
  hist(df[which(df$phone_type == "smartphone"), i], main = "", breaks = seq(min(df[,i]-1), max(df[,i])+1), col="purple", xlim=c(min(df[,i])-1, max(df[,i])+1))
  hist(df[which(df$phone_type == "phone"), i], breaks = seq(min(df[,i]-1), max(df[,i])+1), main = "", col="yellow", add=T)
}
```


```{r}
layout(mat=matrix(c(1,2),2,1,byrow = TRUE), height = c(1,8) )
par(mar=c(0,3.1,1.1,2.1))
boxplot(df$memory_size ~ df$phone_type, horizontal = TRUE,  xaxt = "n", col= "yellow", frame= F, main="memory_size", ylim=c(4, 23))
par(mar=c(4,3.1,1.1,2.1))
hist(df$memory_size[which(df$phone_type == "smartphone")], breaks=5:25, main = "", col="purple", xlim=c(4, 23))
hist(df$memory_size[which(df$phone_type == "phone")], breaks=5:25, main = "", col="yellow", add=T)
```

```{r}
layout(mat=matrix(c(1,2),2,1,byrow = TRUE), height = c(1,8) )
par(mar=c(0,3.1,1.1,2.1))
boxplot(df$battery_size ~ df$phone_type, horizontal = TRUE,  xaxt = "n", col= "yellow", frame= F, main="battery_size", ylim=c(5.5, 10.5))
par(mar=c(4,3.1,1.1,2.1))
hist(df$battery_size[which(df$phone_type == "smartphone")], breaks=seq(from=5, to=10, by=0.25), main = "", col="purple", xlim=c(5.5, 10.5))
hist(df$battery_size[which(df$phone_type == "phone")], breaks=seq(from=5, to=10, by=0.25), main = "", col="yellow", add=T)
```
```{r}
layout(mat=matrix(c(1,2),2,1,byrow = TRUE), height = c(1,8) )
par(mar=c(0,3.1,1.1,2.1))
boxplot(df$screen_size ~ df$phone_type, horizontal = TRUE,  xaxt = "n", col= "yellow", frame= F, main="screen_size", ylim=c(0, 12))
par(mar=c(4,3.1,1.1,2.1))
hist(df$screen_size[which(df$phone_type == "smartphone")], breaks=seq(from=0, to=10, by=1), main = "", col="purple", xlim=c(0, 12))
hist(df$screen_size[which(df$phone_type == "phone")], breaks=seq(from=0, to=10, by=1), main = "", col="yellow", add=T)
```

```{r}
tmp <- sort(table(df$brand_name))

barplot(tmp, main="brand_names", col="purple")
abline(h=40, col="red", lwd=2)
abline(h=20, col="blue", lwd=2)
abline(h=10, col="green", lwd=2)
abline(h=1, col="yellow", lwd=2)
abline(h=5, col="orange", lwd=2)
```
```{r}
c("Total"=sum(tmp),
"Leq 5"=sum(tmp[tmp <= 5]),
"Proportion (%)"=sum(tmp[tmp <= 5])/sum(tmp) * 100)
```

#### Other
```{r}
to_remove <- names(tmp[tmp <= 5])

vals <- c()
for (i in 1:length(levels(df$brand_name))){
  if (any(levels(df$brand_name)[i] == to_remove)){
    vals <- c(vals, "other")
  } else {
    vals <- c(vals, levels(df$brand_name)[i])
  }
}

levels(df$brand_name) <- vals
```

#### Drop
```{r}
#to_remove <- names(tmp[tmp <= 5])

#idxs <- c()
#for (i in 1:length(df$brand_name)){
#  if (any(df$brand_name[i] == to_remove)){
#    idxs <- c(idxs, i)
#  }
#}

#df <- df[-idxs,]

#vals <- c()
#for (i in 1:length(levels(df$brand_name))){
#  if (any(levels(df$brand_name)[i] == to_remove)){
#    vals <- c(vals, "Samsung")
#  } else {
#    vals <- c(vals, levels(df$brand_name)[i])
#  }
#}

#¯levels(df$brand_name) <- vals
```

```{r}
tmp <- sort(table(df$brand_name))

barplot(tmp, main="brand_names", col="purple")
```


## Train-Test Split

```{r}
split <- initial_split(df, prop = 0.7)
train <- training(split)
test <- testing(split)

for (i in 8:11){
  mu  <- mean(train[, i])
  std <- sd(train[, i])
  
  train[, i] <- (train[, i] - mu) / std
  test[, i] <- (test[, i] - mu) / std
}
```

# Model fitting

```{r}
summary(df)
summary(test)
```


## Linear model
### Default

Aggiungere le interazioni, capire come gestire brand_name
```{r warning=FALSE}
lm_model <- lm(best_price ~ brand_name + os + phone_type + sellers_amount + screen_size + memory_size + battery_size + month + year + phone_type + popularity_levels, data = train)
summary(lm_model)

y_hat <- predict(lm_model, newdata = train)
pred <- predict(lm_model, newdata = test)
c("RMSE"=RMSE(y_hat, train$best_price), "R2"=R2(y_hat, train$best_price), "RMSE_test"=RMSE(pred, test$best_price), "R2_test"=R2(pred, test$best_price), "AIC"=AIC(lm_model), "BIC" = BIC(lm_model))
```


## Testing with interactions
```{r warning=FALSE}
lm_model <- lm(best_price ~ brand_name + os + phone_type + sellers_amount + screen_size + phone_type*screen_size + phone_type*memory_size + memory_size + battery_size + month + year + phone_type + popularity_levels, data = train)
summary(lm_model)

y_hat <- predict(lm_model, newdata = train)
pred <- predict(lm_model, newdata = test)
c("RMSE"=RMSE(y_hat, train$best_price), "R2"=R2(y_hat, train$best_price), "RMSE_test"=RMSE(pred, test$best_price), "R2_test"=R2(pred, test$best_price), "AIC"=AIC(lm_model))
```
## Testing removing some vars

removed: month, pop, sellers amount
```{r warning=FALSE}
lm_model <- lm(best_price ~ brand_name + os + phone_type + screen_size + memory_size + battery_size +  year + phone_type, data = train)
summary(lm_model)

y_hat <- predict(lm_model, newdata = train)
pred <- predict(lm_model, newdata = test)
c("RMSE"=RMSE(y_hat, train$best_price), "R2"=R2(y_hat, train$best_price), "RMSE_test"=RMSE(pred, test$best_price), "R2_test"=R2(pred, test$best_price), "AIC"=AIC(lm_model), "BIC" = BIC(lm_model))
```
### Testing removing vars + interactions 
same removed vars
```{r warning=FALSE}
lm_model <- lm(best_price ~ brand_name + os + phone_type + screen_size*phone_type + screen_size + memory_size*phone_type + memory_size + battery_size +  year + phone_type, data = train)
summary(lm_model)

y_hat <- predict(lm_model, newdata = train)
pred <- predict(lm_model, newdata = test)
c("RMSE"=RMSE(y_hat, train$best_price), "R2"=R2(y_hat, train$best_price), "RMSE_test"=RMSE(pred, test$best_price), "R2_test"=R2(pred, test$best_price), "AIC"=AIC(lm_model), "BIC" = BIC(lm_model))
```

## GAM
### Default
```{r fig.height=5, fig.width=5}
fit_gam <- gam(best_price ~ os + phone_type + screen_size + memory_size + battery_size + month + phone_type + popularity_levels, data = train)
summary(fit_gam)

y_hat <- predict(fit_gam, newdata = train)
pred <- predict(fit_gam, newdata = test)
c("RMSE"=RMSE(y_hat, train$best_price), "R2"=R2(y_hat, train$best_price), "RMSE_test"=RMSE(pred, test$best_price), "R2_test"=R2(pred, test$best_price), "AIC"=AIC(fit_gam))
```

### With Splines
```{r}
fit_gam <- gam(best_price ~ os + s(screen_size) + s(memory_size) + s(battery_size) + month + phone_type + popularity_levels, data = train)
summary(fit_gam)

y_hat <- predict(fit_gam, newdata = train)
pred <- predict(fit_gam, newdata = test)
c("RMSE"=RMSE(y_hat, train$best_price), "R2"=R2(y_hat, train$best_price), "RMSE_test"=RMSE(pred, test$best_price), "R2_test"=R2(pred, test$best_price), "AIC"=AIC(fit_gam))
```

## Regression Tree
```{r fig.height=10, fig.width=10}
fit_tree <- rpart(best_price ~ brand_name + os + phone_type + screen_size + memory_size + battery_size + month + year + phone_type + popularity_levels, data = train)
rpart.plot(fit_tree)
plotcp(fit_tree)

pred <- predict(fit_tree, newdata = test)
c("RMSE"=RMSE(y_hat, train$best_price), "R2"=R2(y_hat, train$best_price), "RMSE_test"=RMSE(pred, test$best_price), "R2_test"=R2(pred, test$best_price))
```

## Random Forest
```{r}
library(randomForest)
fit_rf <- randomForest(best_price ~ brand_name + os + phone_type + screen_size + memory_size + battery_size + month + year + phone_type + popularity_levels, data = train, ntree=500, importance=T, proximitry=T, mtry=5)

y_hat <- predict(fit_rf, newdata = train)
pred <- predict(fit_rf, newdata = test)
c("RMSE"=RMSE(y_hat, train$best_price), "R2"=R2(y_hat, train$best_price), "RMSE_test"=RMSE(pred, test$best_price), "R2_test"=R2(pred, test$best_price))

varImpPlot(fit_rf, sort=T, n.var= 8, main= "Historical area vs. currently present", pch=16)
```

## MARS
```{r}
library(earth)     # fit MARS models

fit_mars <- earth(best_price ~ brand_name + os + phone_type + screen_size + memory_size + battery_size + month + year + phone_type + popularity_levels, data = train)
fit_mars

y_hat <- predict(fit_mars, newdata = train)
pred <- predict(fit_mars, newdata = test)
c("RMSE"=RMSE(y_hat, train$best_price), "R2"=R2(y_hat, train$best_price), "RMSE_test"=RMSE(pred, test$best_price), "R2_test"=R2(pred, test$best_price))
```

# Test

```{r warning=FALSE}

library(randomForest)
tmp <- sort(table(df$brand_name))
df2 <- df

RMSE_tr <- c()
RMSE_te <- c()
R2_tr <- c()
R2_te <- c()
AIC_tr <- c()

for (j in 1:15) {
  df <- df2
  to_remove <- names(tmp[tmp <= j])

  vals <- c()
  for (i in 1:length(levels(df$brand_name))){
    if (any(levels(df$brand_name)[i] == to_remove)){
      vals <- c(vals, "other")
    } else {
      vals <- c(vals, levels(df$brand_name)[i])
    }
  }

  levels(df$brand_name) <- vals

  mean_RMSE_tr <- c()
  mean_RMSE_te <- c()
  mean_R2_tr <- c()
  mean_R2_te <- c()
  mean_AIC_tr <- c()
  
  for (k in 1:10) {
    split <- initial_split(df, prop = 0.7, strata = "brand_name")
    train <- training(split)
    test <- testing(split)

    for (i in 8:11){
      mu  <- mean(train[, i])
      std <- sd(train[, i])
  
      train[, i] <- (train[, i] - mu) / std
      test[, i] <- (test[, i] - mu) / std
    }

    model <- randomForest(best_price ~ brand_name + os + phone_type + screen_size + memory_size + battery_size + month + year + phone_type + popularity_levels, data = train, ntree=500, importance=T, proximitry=T, mtry=5)
    #model <- lm(best_price ~ brand_name + os + phone_type + sellers_amount + screen_size + memory_size + battery_size + month + year + phone_type + popularity_levels, data = train)

    y_hat <- predict(model, newdata = train)
    pred <- predict(model, newdata = test)
    
    mean_RMSE_tr <- c(mean_RMSE_tr, RMSE(y_hat, train$best_price))
    mean_RMSE_te <- c(mean_RMSE_te, RMSE(pred, test$best_price))
    mean_R2_tr <- c(mean_R2_tr, R2(y_hat, train$best_price))
    mean_R2_te <- c(mean_R2_te, R2(pred, test$best_price))
    #mean_AIC_tr <- c(mean_AIC_tr, AIC(model))
  }

  RMSE_tr <- c(RMSE_tr, mean(mean_RMSE_tr))
  RMSE_te <- c(RMSE_te, mean(mean_RMSE_te))
  R2_tr <- c(R2_tr, mean(mean_R2_tr))
  R2_te <- c(R2_te, mean(mean_R2_te))
  AIC_tr <- c(AIC_tr, mean(mean_AIC_tr))
}
```

```{r}
plot(RMSE_tr, type="l", col="red", ylim=c(0, 0.5))
lines(RMSE_te, col="blue")
abline(v=which.min((RMSE_te+RMSE_tr)/2), col="green", lwd=2)
legend("topright", legend=c("Train", "Test", "Best"), col=c("red", "blue", "green"), lty=1:1)

plot(R2_tr, type="l", col="red", ylim=c(0, 1))
lines(R2_te, col="blue")
abline(v=which.max(R2_te+R2_tr), col="darkgreen", lwd=2)
legend("bottomleft", legend=c("Train", "Test", "Best"), col=c("red", "blue", "darkgreen"), lty=1:1)

#plot(AIC_tr, type="l", col="red")
#abline(v=which.min((RMSE_te+RMSE_tr)/2), col="green", lwd=2)
#abline(v=which.max(R2_te+R2_tr), col="darkgreen", lwd=2)
#legend("topright", legend=c("AIC", "Best RMSE", "Best R2"), col=c("red", "green", "darkgreen"), lty=1:1)
```


```{r}
c("RMSE"=RMSE(y_hat, train$best_price), "R2"=R2(y_hat, train$best_price), "RMSE_test"=RMSE(pred, test$best_price), "R2_test"=R2(pred, test$best_price), "AIC"=AIC(model))
}
```


```{r}
train_control <- trainControl(method="LOOCV")

model <- train(best_price ~ brand_name + os + phone_type + screen_size + memory_size + battery_size + month + year, data=train, method="lm", trControl=train_control)
summary(model)

y_hat <- predict(model, newdata = train)
pred <- predict(model, newdata = test)
c("RMSE"=RMSE(y_hat, train$best_price), "R2"=R2(y_hat, train$best_price), "RMSE_test"=RMSE(pred, test$best_price), "R2_test"=R2(pred, test$best_price), "AIC"=AIC(lm_model))
```

```{r}
library(glmnet)

ridge <- glmnet(train[, -c(1, 2, 4, 5, 6, 7)], train$best_price, alpha=0)

plot(ridge, xvar = "lambda", label = TRUE)
plot(ridge, xvar = "dev", label = TRUE)
```

