---
title: "Final_Project"
author: "Nicola Cortinovis, Roberta Lamberti, Marta Lucas, Stefano Tumino"
date: "`r Sys.Date()`"
output: html_document
---
# Initial setup
```{r}
#install.packages("mgcv")
#install.packages("dplyr")
#install.packages("rpart")
#install.packages("rpart.plot")
#install.packages("ipred")
#install.packages("caret")
#install.packages("stringr")
#install.packages("ggcorrplot")
```

## Import libraries
```{r}
library(stringr)
library(mgcv)        # GAMs
library(rsample)     # data splitting
library(dplyr)       # data wrangling
library(rpart)       # performing regression trees
library(rpart.plot)  # plotting regression trees
library(ipred)       # bagging
library(caret)
library(ggcorrplot)
```

## Import dataset
```{r}
df <- read.csv("phones_data.csv", header=T)

summary(df)
```

## Variable cleaning

### Remove useless variables
TODO: elenco variabili categoriali e spiegazioni sul dataset
```{r}
# rimozione colonna degli indici
df$X <- NULL
```

### Factorize the categorical variables
```{r}
df$brand_name <- factor(df$brand_name)
df$os <- factor(df$os)
```

 
Let's divide the popularity into levels,assigning three levels associated with a numeric score.
- From 0 to 400 -> low
- From 401 to 800 -> medium
- From 801 to 1224 -> high
```{r}
df$popularity <- as.numeric(df$popularity)

tag <- c(0,400, 800, Inf)

df$popularity_levels <- cut(df$popularity, breaks = tag,
labels=c("low", "medium", "high"), include.lowest=TRUE)
```

### Convert the prices to euros
```{r}

df$best_price <- df$best_price*0.024
df$lowest_price <- df$lowest_price*0.024
df$highest_price <- df$highest_price*0.024
```

### Make the os variable more readable
```{r}
levels(df$os) <- c("other", "Android", "other", "iOS", "other", "other", "other")
```

### Split the timestamps
```{r}
df$month <- as.numeric(sapply(df$release_date, FUN = function(x) {strsplit(x, split = '[-]')[[1]][1]}))
df$year <- as.numeric(sapply(df$release_date, FUN = function(x) {strsplit(x, split = '[-]')[[1]][2]}))-2000
```

# Dataset cleaning 
- sistema operativo mancante modelli molto vecchi di telefoni, non sono smartphone 
- memory size mancante per gli stessi 

## Remove duplicated rows
```{r}

idxs <- which(duplicated(df[,c(-2, -4)]))

succ <- idxs[-length(idxs)] - idxs[-1] == -1
succ <- c(succ, FALSE)

i = 1
while (i <= length(idxs)){
  start = idxs[i]-1
  sum <- c(df$popularity[idxs[i]])
  while (succ[i] == TRUE){
    i = i + 1
    sum <- c(sum, df$popularity[idxs[i]])
  }
  df$popularity[start] <- mean(c(sum, df$popularity[start]))
  i = i + 1
}

df <- df[-idxs, ]

```

## Manage missing values
Since there are only 10 missing values for battery size and 2 NAs for screen size, we can drop those observations.

We notice that most of the missing values for memory size are relative to phones that are not smart-phones, for this reason we decided to substitute them with the median of the values for memory size of non-smartphones.TODO: sistemare
For the highest/lowest price we'll just substitute the mean of those columns.

### Drop Battery and Screen size missing values rows
```{r}
df <- df[- which(is.na(df$battery_size)),]
df <- df[- which(is.na(df$screen_size)),]
```

### Impute memory size missing values

We notice that most of the missing values are not smartphones... (os) TODO: spiegare quello che abbiamo fatto per la media
```{r}
tmp <- df[which(df$os == "other"),]$memory_size
df$memory_size[which(is.na(df$memory_size))] <- median(tmp[-which(is.na(tmp))])
```


### substitute the highest/lowest price NA with the median of the column
```{r}
tmp <- which(is.na(df$lowest_price))
df$lowest_price[tmp] <- median(df$lowest_price[-tmp])
```

```{r}
tmp <- which(is.na(df$highest_price))
df$highest_price[tmp] <- median(df$highest_price[-tmp])

```

### Remove useless variables
```{r}
# remove useless variables
#df$model_name <- NULL
#df$release_date <- NULL
#df$popularity <- NULL
```

# Data Analysis
## Correlation matrix
```{r}
corr <- cor(df[, c(-1,-2, -3, -12, -13, -14, -15)], use="complete.obs" )

ggcorrplot(corr, hc.order = TRUE, lab = TRUE, colors=c("yellow", "white", "purple"))
```
TODO: explain what columns need to be removed (highest/lowest price)
## Single plots and Outlier analysis
### Numerical
TODO: -boxplots/other ideas
```{r}
cols <- 5:11

for (i in cols) {
  layout(mat=matrix(c(1,2),2,1,byrow = TRUE), height = c(1,8) )
  par(mar=c(0,3.1,1.1,2.1))
  boxplot(df[, i], horizontal = TRUE,  xaxt = "n", col= "yellow", frame= F, main=colnames(df)[i])
  par(mar=c(4,3.1,1.1,2.1))
  hist(df[, i],border = F, main = "", col="purple")
}
```
### Categorical
```{r}
for (i in c(1, 3, 13)) {
  barplot(sort(table(df[, i])), main=colnames(df)[i], col="purple")
}

for (i in c(1, 3, 13)) {
  boxplot(df$best_price ~ df[, i],  xaxt = "n", col= "yellow", frame= F, main=colnames(df)[i])
}
```

### Pairs plot
```{r fig.height=7.5, fig.width=7.5}
pairs(df[cols], pch=19, lower.panel=panel.smooth)
```

# Preprocessing

## Transformations

### Log transformation
```{r}
for (i in c(5:8, 11)){
  df[, i] <- log(df[, i])
}
```

### Log2 transformation
```{r}
df$memory_size <- floor(log2(df$memory_size*1e4))
```

### Add categorical variable

The variables memory size and screen size are bimodal, we can add a categorical variable which differentiate smartphones from phones.
We can do this setting to 1 (smartphone) if the memory size is greater than 14 and the screen size is greater than 3.5, 0 (phones) otherwise.
```{r}
df$phone_type <- factor((df$memory_size < 14), labels = c("smartphone", "phone"))
```

```{r}
layout(mat=matrix(c(1,2),2,1,byrow = TRUE), height = c(1,8) )
par(mar=c(0,3.1,1.1,2.1))
boxplot(df$memory_size ~ df$phone_type, horizontal = TRUE,  xaxt = "n", col= "yellow", frame= F, main="memory_size", ylim=c(4, 23))
par(mar=c(4,3.1,1.1,2.1))
hist(df$memory_size[which(df$phone_type == "smartphone")], breaks=5:25, main = "", col="purple", xlim=c(4, 23))
hist(df$memory_size[which(df$phone_type == "phone")], breaks=5:25, main = "", col="yellow", add=T)
```


```{r}
layout(mat=matrix(c(1,2),2,1,byrow = TRUE), height = c(1,8) )
par(mar=c(0,3.1,1.1,2.1))
boxplot(df$battery_size ~ df$phone_type, horizontal = TRUE,  xaxt = "n", col= "yellow", frame= F, main="battery_size", ylim=c(5.5, 10.5))
par(mar=c(4,3.1,1.1,2.1))
hist(df$battery_size[which(df$phone_type == "smartphone")], breaks=seq(from=5, to=10, by=0.25), main = "", col="purple", xlim=c(5.5, 10.5))
hist(df$battery_size[which(df$phone_type == "phone")], breaks=seq(from=5, to=10, by=0.25), main = "", col="yellow", add=T)
```

```{r}
tmp <- sort(table(df$brand_name))

barplot(tmp, main="brand_names", col="purple")
abline(h=40, col="red", lwd=2)
abline(h=20, col="blue", lwd=2)
abline(h=10, col="green", lwd=2)
abline(h=1, col="yellow", lwd=2)
```


## Train-Test Split

```{r}
split <- initial_split(df, prop = 0.7)
train <- training(split)
test <- testing(split)

for (i in 8:11){
  mu  <- mean(train[, i])
  std <- sd(train[, i])
  
  train[, i] <- (train[, i] - mu) / std
  test[, i] <- (test[, i] - mu) / std
}
```

# Model fitting

```{r}
summary(df)
summary(test)
```


## Linear model
### Default
```{r}
lm_model <- lm(best_price ~ os + phone_type + sellers_amount + screen_size + memory_size + battery_size + month + year, data = train)
summary(lm_model)

y_hat <- predict(lm_model, newdata = train)
pred <- predict(lm_model, newdata = test)
c("RMSE"=RMSE(y_hat, train$best_price), "R2"=R2(y_hat, train$best_price), "RMSE_test"=RMSE(pred, test$best_price), "R2_test"=R2(pred, test$best_price), "AIC"=AIC(lm_model))
```

### Without Seller Amount
```{r}
lm_model <- lm(best_price ~ os + phone_type + screen_size + memory_size + battery_size + month, data = train)
summary(lm_model)

y_hat <- predict(lm_model, newdata = train)
pred <- predict(lm_model, newdata = test)
c("RMSE"=RMSE(y_hat, train$best_price), "R2"=R2(y_hat, train$best_price), "RMSE_test"=RMSE(pred, test$best_price), "R2_test"=R2(pred, test$best_price), "AIC"=AIC(lm_model))
```

## GAM
### Default
```{r}
fit_gam <- gam(best_price ~ os + phone_type + screen_size + memory_size + battery_size + month, data = train)
summary(fit_gam)

y_hat <- predict(fit_gam, newdata = train)
pred <- predict(fit_gam, newdata = test)
c("RMSE"=RMSE(y_hat, train$best_price), "R2"=R2(y_hat, train$best_price), "RMSE_test"=RMSE(pred, test$best_price), "R2_test"=R2(pred, test$best_price), "AIC"=AIC(fit_gam))
```

### With Splines
```{r}
fit_gam <- gam(best_price ~ os + s(screen_size) + s(memory_size) + s(battery_size) + month, data = train)
summary(fit_gam)

y_hat <- predict(fit_gam, newdata = train)
pred <- predict(fit_gam, newdata = test)
c("RMSE"=RMSE(y_hat, train$best_price), "R2"=R2(y_hat, train$best_price), "RMSE_test"=RMSE(pred, test$best_price), "R2_test"=R2(pred, test$best_price), "AIC"=AIC(fit_gam))
```

## Regression Tree
```{r fig.height=15, fig.width=15}
fit_tree <- rpart(best_price ~ brand_name + os + phone_type + screen_size + memory_size + battery_size + month + year, data = train)
rpart.plot(fit_tree)
plotcp(fit_tree)

pred <- predict(fit_tree, newdata = test)
c("RMSE"=RMSE(y_hat, train$best_price), "R2"=R2(y_hat, train$best_price), "RMSE_test"=RMSE(pred, test$best_price), "R2_test"=R2(pred, test$best_price))
```

## Random Forest
```{r}
library(randomForest)
fit_rf <- randomForest(best_price ~ os + phone_type + screen_size + memory_size + battery_size + month + year, data = train)
fit_rf

y_hat <- predict(fit_rf, newdata = train)
pred <- predict(fit_rf, newdata = test)
c("RMSE"=RMSE(y_hat, train$best_price), "R2"=R2(y_hat, train$best_price), "RMSE_test"=RMSE(pred, test$best_price), "R2_test"=R2(pred, test$best_price))
```